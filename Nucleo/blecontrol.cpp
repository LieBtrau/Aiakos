#include "blecontrol.h"
#include "rn4020.h"
#include "btcharacteristic.h"

#ifdef ARDUINO_AVR_PROTRINKET3FTDI
#include <SoftwareSerial.h>
extern SoftwareSerial* sw;
rn4020 rn(Serial,5,A3,A4,6);
SoftwareSerial* sPortDebug;
#elif defined(ARDUINO_STM_NUCLEO_F103RB)
/*Connections between Nucleo and RN4020
 * RN4020.1 -> GND
 * RN4020.5 -> D2
 * RN4020.6 -> D8
 * RN4020.7 -> D3
 * RN4020.12 -> D4
 * RN4020.15 -> D5
 * RN4020.PWREN -> D6
 * RN4020.3V3 -> 3V3
 */
rn4020 rn(Serial1, 3, 4, 5, 6);
extern HardwareSerial* sw;
#endif

static void connectionEvent(bool bConnectionUp);
static void alertLevelEvent(char* value, byte& length);

//https://www.bluetooth.com/specifications/gatt/services
//https://www.bluetooth.com/specifications/gatt/characteristics
static btCharacteristic ias_alertLevel("1802",                                  //IAS Alert Service
                                       "2A06",                                  //Alert Level characteristic
                                       btCharacteristic::WRITE_WOUT_RESP, 1,    //properties+length
                                       btCharacteristic::NOTHING);              //security
//Private UUIDs have been generated by: https://www.uuidgenerator.net/version4
static btCharacteristic rfid_key("f1a87912-5950-479c-a5e5-b6cc81cd0502",        //private service
                                 "855b1938-83e2-4889-80b7-ae58fcd0e6ca",               //private characteristic
                                 btCharacteristic::WRITE_WOUT_RESP,5,                  //properties+length
                                 btCharacteristic::ENCR_W);                            //security

bleControl::bleControl()
{
}

bool bleControl::begin(bool bCentral)
{
    if(!rn.begin(2400))
    {
        //Maybe the module is blocked or set to an unknown baudrate?
        if(!rn.doFactoryDefault())
        {
            return false;
        }
        //Factory default baud=115200
        if(!rn.begin(115200))
        {
            return false;
        }
        //Switch to 2400baud
        // + It's more reliable than 115200baud with the ProTrinket 3V.
        // + It also works when the module is in deep sleep mode.
        if(!rn.setBaudrate(2400))
        {
            return false;
        }
        //Baudrate only becomes active after resetting the module.
        if(!rn.doReboot(2400))
        {
            return false;
        }
    }
    rn.setConnectionListener(connectionEvent);
    if(bCentral)
    {
        //Central
        //    ble2_reset_to_factory_default(RESET_SOME);
        //    ble2_set_server_services(0xC0000000);
        //    ble2_set_supported_features(0x82480000);
        //    ble2_device_reboot();
    }else
    {
        //Peripheral
        //Check if settings have already been done.  If yes, we don't have to set them again.
        //This is check is performed by checking if the last setting command has finished successfully:
        char dataname[20];
        const char BT_NAME[]="AiakosKeyFob";
        if(!rn.getBluetoothDeviceName(dataname))
        {
            return false;
        }
        if(!strncmp(dataname,BT_NAME, strlen(BT_NAME)))
        {
            return true;
        }
        if(!rn.setRole(rn4020::PERIPHERAL))
        {
            return false;
        }
        if(!rn.setTxPower(0))
        {
            return false;
        }
        if(!rn.removePrivateCharacteristics())
        {
            return false;
        }
        //Power must be cycled after removing private characteristics
        if(!rn.begin(2400))
        {
            return false;
        }
        if(!rn.addCharacteristic(&rfid_key))
        {
            return false;
        }
        ias_alertLevel.setListener(alertLevelEvent);
        if(!rn.addCharacteristic(&ias_alertLevel))
        {
            return false;
        }
        //Normally reboot needed to make changes take effect, but that has already been done by adding characteristics.
        //Start advertizing to make the RN4020 discoverable & connectable
        if(!rn.doAdvertizing(true,5000))
        {
            return false;
        }
        //If the following statement is commented out, the addCharacteristic function will no longer work.
        if(!rn.setOperatingMode(rn4020::DEEP_SLEEP))
        {
            return false;
        }
//        byte mac[6];
//        byte macLength;
//        if(!rn.getMacAddress(mac, macLength))
//        {
//            return false;
//        }
//        for(byte i=0;i<macLength;i++)
//        {
//            Serial.println(mac[i], HEX);
//        }
        if(!rn.setBluetoothDeviceName(BT_NAME))
        {
            return false;
        }
    }
    return true;
}

bool bleControl::loop()
{
    rn.loop();
}

void connectionEvent(bool bConnectionUp)
{
    if(bConnectionUp)
    {
        sw->println("up");
    }else
    {
        sw->println("down");
        //After connection went down, advertizing must be restarted or the module will no longer be connectable.
        if(!rn.doAdvertizing(true,5000))
        {
            return;
        }
    }
}

void alertLevelEvent(char* value, byte &length)
{
    for(byte i=0;i<length;i++)
    {
        sw->print(value[i], HEX);
        sw->print(" ");
    }
    sw->println();
}

