#include "keyfob.h"

static void bleEvent(bleControl::EVENT ev);
static void alertLevelEvent(byte *value, byte& length);
static void rfidEvent(byte *value, byte& length);
extern bool readDataSer(byte* data, byte& length);
extern bool writeDataSer(byte* data, byte length);

namespace {
byte payload[4]={0xFE, 0xDC, 0xBA, 0x98};
Configuration* cfg;

//Private UUIDs have been generated by: https://www.uuidgenerator.net/version4
btCharacteristic rfid_key("f1a87912-5950-479c-a5e5-b6cc81cd0502",        //private service
              "855b1938-83e2-4889-80b7-ae58fcd0e6ca",        //private characteristic
              btCharacteristic::WRITE_WOUT_RESP,5,           //properties+length
              btCharacteristic::ENCR_W,                      //security
              rfidEvent);                                    //eventhandler
//https://www.bluetooth.com/specifications/gatt/services
//https://www.bluetooth.com/specifications/gatt/characteristics
btCharacteristic ias_alertLevel("1802",                                  //IAS Alert Service
                "2A06",                                  //Alert Level characteristic
                btCharacteristic::WRITE_WOUT_RESP, 1,    //properties+length
                btCharacteristic::NOTHING,               //security
                alertLevelEvent);
btCharacteristic* _localCharacteristics[2]={&rfid_key, &ias_alertLevel};
KeyFob* thiskeyfob;
bool bConnected;
unsigned long connectionTimeout;
const unsigned long CONNECTION_TIMEOUT=30000;
}

KeyFob::KeyFob(byte ownAddress,
           Configuration* config,
           RH_RF95 *prhLora,
           RH_Serial *prhSerial,
           byte buttonPin,
           byte cableDetectPin,
           bleControl* pble,
           byte tonePin):
    LoRaDevice(ownAddress, prhLora, prhSerial, cableDetectPin),
    buttonPin(buttonPin),
    serProtocol(ECDHCOMM),
    _ble(pble),
    _blePair(writeDataSer, readDataSer, pble),
    tonePin(tonePin)
{
    pushButton = Bounce();
    cfg=config;
    setPeerAddress(1);
    _ble->setEventListener(bleEvent);
    thiskeyfob=this;
}

bool KeyFob::setup()
{
    if(!LoRaDevice::setup())
    {
    return false;
    }
    if(!initBlePeripheral())
    {
    debug_println("Ble init failed.");
    return false;
    }
    pinMode(buttonPin, INPUT_PULLUP);
    pushButton.attach(buttonPin);
    pushButton.interval(100); // interval in ms
    return true;
}

void KeyFob::loop()
{
    if(millis()-connectionTimeout>CONNECTION_TIMEOUT)
    {
    if(bConnected)
    {
        debug_println("Connection timeout");
        _ble->disconnect();
    }
    connectionTimeout=millis();
    }
    cableDetect.update();
    pushButton.update();
    if(!cableDetect.read())
    {
    //Secure pairing mode
    if(pushButton.fell())
    {
        debug_println("Starting BLE pairing...");
        serProtocol=BLE_BOND;
        setPeerAddress(3);
        if(!_blePair.startPairing())
        {
        debug_println("Starting ECDH pairing...");
        serProtocol=ECDHCOMM;
        setPeerAddress(1);
        k.reset();
        if(!ecdh.startPairing())
        {
            debug_println("ECDH pairing doesn't start");
        }
        return;
        }
    }
    switch(serProtocol)
    {
    case ECDHCOMM:
        switch(ecdh.loop())
        {
        case EcdhComm::AUTHENTICATION_OK:
        debug_println("Securely paired");
        cfg->addKey(ecdh.getRemoteId(), ecdh.getMasterKey());
        break;
        case EcdhComm::NO_AUTHENTICATION:
        case EcdhComm::AUTHENTICATION_BUSY:
        break;
        case EcdhComm::UNKNOWN_DATA:
        serProtocol=UNKNOWN;
        break;
        }
        break;
    case UNKNOWN:
        //find out the correct protocol
        break;
    case BLE_BOND:
        switch(_blePair.loop())
        {
        case BlePairing::AUTHENTICATION_OK:
        debug_println("Bonded with bike.");
        _ble->disconnect();
        if(!storeKey())
        {
            debug_println("rfidkey can't be stored");
        }
        break;
        case BlePairing::NO_AUTHENTICATION:
        mgrSer.resetDatagram();
        break;
        case BlePairing::AUTHENTICATION_BUSY:
        break;
        }
        break;
    }
    }else
    {
    //Authenticating remote peer mode
    if(pushButton.fell())
    {
        ecdh.reset();
        debug_println("Initiator starts authentication");
        if(!k.sendMessage(payload,sizeof(payload), cfg->getDefaultId(), cfg->getIdLength(), cfg->getDefaultKey()))
        {
        debug_println("Sending message failed.");
        return;
        }
    }
    if(k.loop()==KryptoKnightComm::AUTHENTICATION_AS_INITIATOR_OK)
    {
        debug_println("Message received by peer and acknowledged");
    }
    _ble->loop();
    }
}

void KeyFob::event(bleControl::EVENT ev)
{
    connectionTimeout=millis();
    switch(ev)
    {
    case bleControl::EV_PASSCODE_WANTED:
    _blePair.eventPasscodeInputRequested();
    break;
    case bleControl::EV_CONNECTION_DOWN:
    debug_println("Connection down");
    //After connection goes down, advertizing must be restarted or the module will no longer be connectable.
    if(!_ble->startAdvertizement(5000))
    {
        debug_print("Can't start advertizing.");
        return;
    }
    bConnected=false;
    break;
    case bleControl::EV_CONNECTION_UP:
    debug_println("Connection up");
    connectionTimeout=millis();
    bConnected=true;
    break;
    case bleControl::EV_BONDING_BONDED:
    _blePair.eventBondingBonded();
    break;
    default:
    debug_print("Unknown event: ");
    debug_println(ev, DEC);
    break;
    }

}


void bleEvent(bleControl::EVENT ev)
{
    thiskeyfob->event(ev);
}

bool KeyFob::initBlePeripheral()
{
    char dataname[20];
    const char BT_NAME_KEYFOB[]="AiakosKeyFob";

    if(!_ble->init())
    {
    debug_println("RN4020 not set up");
    return false;
    }
    if(!_ble->getBluetoothDeviceName(dataname))
    {
    return false;
    }
    //Check if programming the settings has already been done.  If yes, we don't have to set them again.
    //This is check is performed by verifying if the last setting command has finished successfully:
    if(strncmp(dataname,BT_NAME_KEYFOB, strlen(BT_NAME_KEYFOB)))
    {
    //Module not yet correctly configured
    if(!_ble->programPeripheral())
    {
        return false;
    }
    if(!_ble->addLocalCharacteristics(_localCharacteristics,2))
    {
        return false;
    }
    if(!_ble->setBluetoothDeviceName(BT_NAME_KEYFOB))
    {
        return false;
    }
    }
    if(!_ble->beginPeripheral(_localCharacteristics,2))
    {
    return false;
    }
    if(_ble->isBonded())
    {
    return _ble->startAdvertizement(5000);
    }
    return true;
}

void KeyFob::alertEvent(byte* value, byte &length)
{
    debug_print("Characteristic changed to: ");
    debug_printArray(value, length);
#ifndef ARDUINO_SAM_DUE
    tone(tonePin, 3120, 500);
#endif
}

void KeyFob::rfidEvent(byte* value, byte &length)
{
    if(!_ble->isBonded() || !_ble->isSecured())
    {
    debug_println("Illegal write of event");
    return;
    }
    byte array[4];
    if(!_blePair.getRfidKey(array) || memcmp(array,value,4))
    {
    debug_println("Wrong data doesn't equal key");
    debug_printArray(value, length);
    return;
    }
    debug_print("Characteristic changed to: ");
    debug_printArray(value, length);
}

bool KeyFob::storeKey()
{
    byte rfidkey[4];
    if(!_blePair.getRfidKey(rfidkey))
    {
    return false;
    }
#ifndef ARDUINO_SAM_DUE
return cfg->setRfidKey(rfidkey);
#endif
}

void alertLevelEvent(byte* value, byte &length)
{
    thiskeyfob->alertEvent(value, length);
}

void rfidEvent(byte* value, byte &length)
{
    thiskeyfob->rfidEvent(value, length);
}
